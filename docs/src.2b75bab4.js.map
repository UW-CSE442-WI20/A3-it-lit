{"version":3,"sources":["index.js"],"names":["diameter","pad","scale","d3","scaleSqrt","svg","select","append","getFilteredData","data","intent","console","log","filter","d","Intent","attr","csvFile","require","enterCircles","nestedData","nest","key","Race","rollup","sum","Math","round","Rate","entries","maxValue","getMaxValue","currMax","value","i","length","max","domain","range","node","selectAll","enter","text","style","getRandomColor","self","frameElement","exitCircles","remove","updateCircles","transition","letters","color","floor","random","csv","Deaths","Population","parseFloat","then","$intentSelector","document","getElementById","onchange","e","target","intentData"],"mappings":"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","file":"src.2b75bab4.js","sourceRoot":"../src","sourcesContent":["// define functions for handling homicide & side-annotation\n\n// suicide & side-annotation\n\n// other granularities\n\n// draw SVG elements, graph titles, axes (fxn w/ dataset input)\n//      mouse-over DoD?\ndiameter = 600;\npad = 20;\nvar scale = d3.scaleSqrt();\nvar svg = d3.select(\"body\").append(\"svg\");\nsvg.attr(\"width\", diameter).attr(\"height\", diameter);\n\n// var filterByIntent = function(d) {\n//     return {\n//         Intent: d.Intent,\n//         Deaths: d.Deaths\n//     };\n// }\nfunction getFilteredData(data, intent) {\n  console.log(intent);\n  if (intent == 1) { // double equals allows interpolation\n    // both homicide and suicide\n    return data;\n  } else if (intent == 2) {\n    // homicide\n    return data.filter(function(d) { return d.Intent === \"Homicide\"});\n  } else {\n    // suicide\n    return data.filter(function(d) { return d.Intent === \"Suicide\"});\n  }\n}\n\n\n// read in CSV data\nconst csvFile = require(\"./fullData.csv\");\nd3.csv(csvFile, function(d) {\n        d.Deaths = +d.Deaths;\n        d.Population = +d.Population;\n        d.Rate = parseFloat(d.Rate);\n        return d;\n}).then(function(d) {\n    var $intentSelector = document.getElementById(\"intent-select\"); \n    var intentData = getFilteredData(d, $intentSelector.value);\n    enterCircles(intentData);\n\n    $intentSelector.onchange = function(e) {\n      console.log($intentSelector.value);\n      var intent = e.target.value;\n      var intentData = getFilteredData(d, intent);\n\n\n      //updateCircles(intentData);\n      exitCircles(intentData);\n      enterCircles(intentData);\n\n    };\n})\n\n// hard cap @ 6 circles, so hard math was performed on rendering\n// hard padding @ 100 on each side, so actual svg is 400x400\nfunction enterCircles(data) {\n  // scale.domain([0, d3.max(data, function(d) { return d.Deaths; })])\n  //     .range([0, d3.max(data, function(d) { return d.Rate; })]); // idk\n\n  var nestedData = d3.nest()\n    .key(function(d) { return d.Race;})\n    .rollup(function(d) {\n      return d3.sum(d, function(d) {\n        return Math.round(d.Rate);  // deaths per 100k\n      })\n    })\n    .entries(data);\n\n  function getMaxValue(d) {\n    var currMax = d[0].value;\n    for (var i = 1; i < d.length; i++) {\n      currMax = Math.max(currMax, d[i].value);\n    }\n    return currMax;\n  }\n  var maxValue = getMaxValue(nestedData);\n\n  scale.domain([0, maxValue])\n    .range([20, (diameter - 200) / nestedData.length]);\n    \n\n  // var bubble = d3.pack(nestedData)\n  //   .size([diameter, diameter])\n  //   .padding(2);\n\n  // var nodes = d3.hierarchy(nestedData).sum(function(d) {\n  //   return Math.round(d.Rate);\n  // });\n  // console.log(nodes);\n  console.log(nestedData);\n\n  var node = svg.selectAll(\".node\")\n  .data(nestedData)\n  .enter()\n  .append(\"g\")\n  .attr(\"class\", \"node\")\n  .attr(\"transform\", function(d, i) {\n    var xOffset = (i+1)*75 + scale(d.value);\n    var yOffset = (i+1)*75 + scale(d.value);\n    // if (i === 0) {\n    //   return \"translate(\" + xOffset + \",\" + yOffset + \")\";\n    // } else {\n    //   var prevX = scale(nestedData[i-1].value) + 50;\n    //   var prevY = 0;\n    //   return \"translate(\" + xOffset + \",\" + yOffset + \")\";\n    // }\n    return \"translate(\" + xOffset + \", \" + yOffset + \")\";\n  });\n\n  node.append(\"title\")\n    .text(function(d, i) {\n      return d.key + \": \" + d.value;\n    });\n\n  node.append(\"circle\")\n    .attr(\"r\", function(d, i) {\n        return scale(d.value);\n    })\n    .attr(\"stroke\", \"black\")\n    .style(\"fill\", function(d,i) {\n        return getRandomColor();\n    });\n\n  node.append(\"text\")\n    .attr(\"dy\", \".2em\")\n    .style(\"text-anchor\", \"middle\")\n    .text(function(d) {\n        return d.key;\n    })\n    .attr(\"font-family\", \"sans-serif\")\n    .attr(\"font-size\", function(d){\n        return scale(d.value)/5;\n    })\n    .attr(\"fill\", \"white\");\n\n  node.append(\"text\")\n    .attr(\"dy\", \"1.3em\")\n    .style(\"text-anchor\", \"middle\")\n    .text(function(d) {\n        return d.value;\n    })\n    .attr(\"font-family\",  \"Gill Sans\", \"Gill Sans MT\")\n    .attr(\"font-size\", function(d){\n        return scale(d.value)/5;\n    })\n    .attr(\"fill\", \"white\");\n\n  d3.select(self.frameElement)\n    .style(\"height\", diameter + \"px\");\n\n\n\n    //Add the circles\n    // svg.selectAll(\"circles\")\n    //   .data(data)\n    //   .enter()\n    //   .append(\"circle\")\n    //   .attr(\"cx\", function(d, i) {  // todo: fix math so don't overlay @ least\n    //       return i*d.Rate + pad;\n    //   })\n    //   .attr(\"cy\", function(d, i) {\n    //       return diameter/2;\n    //   })\n    //   .attr(\"r\", function(d, i) {\n    //       // console.log(d);\n    //       return scale(d.Deaths);\n    //   })\n    //   .attr(\"stroke\", \"black\")\n    //   .attr(\"fill\", getRandomColor()) // color changing\n    //   .append(\"text\")\n    //   .style(\"text-anchor\", \"middle\")\n    //   .attr(\"fill\", \"white\")\n    //   .text(function(d) {\n    //     console.log(\"we here\");\n    //     return d.Race + \": \" + d.Age;\n    //   })\n    }\n\nfunction exitCircles(data) {\n// svg.selectAll(\"circles\")\n//     .data(data)\n//     .exit()\n//     .remove();\n  svg.selectAll(\"g\").remove(); // doesn't allow transitions, but deletes properly.\n}\n\nfunction updateCircles(data) { // need to bind circles to datapoints; not sure how\nsvg.selectAll(\"circles\")\n    .data(data)\n    .transition();\n}\n\n// differentiation on refresh\n// sometimes clashes with the white of the texts\nfunction getRandomColor() {\nvar letters = '0123456789ABCDEF';\nvar color = '#';\nfor (var i = 0; i < 6; i++) {\n  color += letters[Math.floor(Math.random() * 16)];\n}\nreturn color;\n}\n\n    // d3.csv(csvFile, function(d) {\n    //         d.Deaths = +d.Deaths;\n    //         d.Population = +d.Population;\n    //         d.Rate = parseFloat(d.Rate);\n    //         return d;\n    // }).then(function(d) {\n    //     scale.domain([0, d3.max(d, function(d) { return d.Deaths; })])\n    //         .range([0, d3.max(d, function(d) { return d.Rate})]); // idk\n    //     // couple on intent & deaths draw relative sizes\n    //     svg.selectAll(\"circles\")\n    //     .data(d)\n    //     .enter()\n    //     .append(\"circle\")\n    //     .attr(\"cx\", function(d, i) {\n    //         return i*d.Rate + padding;\n    //     })\n    //     .attr(\"cy\", function(d, i) {\n    //         return h/2;\n    //     })\n    //     .attr(\"r\", function(d, i) {\n    //         return scale(d.Deaths);\n    //     })\n    //     .attr(\"fill\", \"magenta\"); // color changing\n    // });\n\n// initial call-back renders homicide bubbles, waits 10 seconds,\n// draws next etc. until end\n\n// set up listeners for on-click / on-drag w/ a slider"]}